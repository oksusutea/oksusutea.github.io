---
layout: post
title: Back-end Developer Interview
categories: [Interview]
tags: [Interview]
description: 
fullview: false
comments: false
---
백엔드 면접 준비를 위한 CS 지식 복습.   
질문에 대한 답변은 **간단**하게, 하지만 해당 지식은 **깊이**있게 공부하도록 하는 것이 목표이다.

# 네트워크
***


<details>
    <summary>사용자가 URL에 https://www.google.com을 입력하고, 엔터를 쳤을 때 발생하는 일련의 작업 설명</summary>
<div markdown="1">

웹통신의 기준으로 흘러가는 관점을 파악
### 브라우저의 URL파싱  
아래의 URL을 입력했다고 가정해보자.
><span style="color:red"> http</span>://<span style="color:orange">www.example.com </span><span style="color:blue">:80 </span><span style="color:green">/path/to/myfile.html </span><span style="color:purple">?key1=value1&key2=value2</span><span style="color:grey"> #SomewhereInTheDocument</span>  
1) <span style="color:red"> http</span>:  
'하이퍼 텍스트 통신 규약'을 사용하라는 뜻.
2)<span style="color:orange">www.example.com </span>  
어떤 웹서버가 요구되는지 명시. 직접 IP주소를 입력하는 것도 가능하지만, 인간의 나태함에 의해 개발된 위대한 도메인 URL을 사용한다.  
3) <span style="color:blue">:80 </span>. 
포트. 기술적으로 웹서버에서 자원을 접근하기 위해 사용되는 gate이다. 표준 HTTP포트 사용시(http:80, https:443) 포트 번호는 생략한다.  
4)<span style="color:green">/path/to/myfile.html </span>  
웹서버 자원에 대한 경로. 초기에는 물리적 파일 위치를 가르켰으나, 요즘은 웹서버에서 추상화한 경로를 표기한다.  
5) <span style="color:purple">?key1=value1&key2=value2</span>  
웹 서버에서 제공되는 추가 파라미터. get방식 사용시 보통 제공된다.  
6) <span style="color:grey"> #SomewhereInTheDocument</span>   
자원 자체에 다른 부분에 대한 anchor(닻), 일종의 북마크이다.   
북마크된 지점에 위치한 내용을 보여주기 위헤 브라우저에서 방향을 알려주며, 요청이 서버에 보내지지는 않는다.

#### 유니코드 문자열 반환  
브라우저는 호스트명에서 ASCII가 아닌 유니코드 문자열을 반환한다.  
한글을 비롯한 유니코드가 있을 때 브라우저가 URL에서 호스트명 부분에 퓨니코드 인코딩을 한다.  
** 퓨니코드 : 도메인 이름에 쓸 수 있는 문자만으로 다른 유니코드 문자를 표기하기 위해 만들어진 인코딩 방식. 가끔 한글을 url에서 표시할 때 %ED%93% 이런 것을 본적있을 것임.

### HSTS 목록 조회
브라우저는 HSTS리스트를 점검한다. 만일 해당 URL이 있을 경우, http로 요청하더라도 자동으로 https로 변환하여 요청하게 된다.  
** 여기서 HSTS(HTTP Strict Transport Security)란 ? HTTP를 허용하지 않고 HTTPS를 통해서만 연결이 가능하도록 하는 기능이다. HTTP를 통한 연결 자체를 허용하지 않으며, 클라이언트측에서 차단되는 장점이 있다.

### DNS 서버를 통해 도메인 주소를 IP주소로 변환. 
우선 로컬 host파일이나 브라우저 캐시에 도메인이 있는지 확인한다.  
사용자의 PC는 가장 먼저, 지정된 DNS서버(우리나라의 경우 통신사 별로 지정된 DNS서버가 있다.)에 DNS Query를 송신한다.(http://www.naver.com으로 가정하자) 그 후 지정된 DNS서버는 Root 네임서버에 www.naver.com을 질의하고, Root 네임서버는 .com 네임서버의 ip주소를 알려준다.   

 그 후 .com 네임서버에 www.naver.com을 질의하면 naver.com 네임서버의 ip주소를 받고, 그곳에 질의를 또 송신하면 www.naver.com의 IP주소를 수신하게 된다.

 이와 같이 여러번 왔다갔다 하는 이유는, 도메인의 계층화 구조에 따라 DNS서버도 계층화되어있기 때문이다. 이렇게 계층화되어 있으므로 도메인의 가장 최상단, 즉 가장 뒷쪽(.com, .kr 등등)을 담당하는 DNS서버는 전세계에 13개 뿐이다.


### 라우터를 통해 해당 서버의 게이트웨이까지 이동
  DNS 서버를 통해 접속하고자 하는 서버의 IP주소를 알아냈다. 이제 이 IP주소로 서버에 요청을 전달해야 한다.  
  이 IP주소로 가야하는 것은 알지만, 어떻게 가야할 지는 모르기 때문에 네트워크 장비인 라우터의 라우팅 테이블을 통해 어떤 경로로 요청할지 지정한다. 이를 통해 서버로 찾아갈 수 있게 된다.

### ARP를 통해 IP주소를 MAC주소로 변환  
ARP(Address Resolution Protocol, 주소 결정 프로토콜)은 OSI 7계층 중에서도, 네트워크 계층 주소와 링크 계층 주소 사이의 변환을 담당하는 'IP 프로토콜'이다.

실질적으로 컴퓨터는 '랜카드'를 사용하여 연결되어 있어, 3계층->2계층으로 데이터를 전달하기 위해서는 MAC주소가 필요하다.
이를 위해 해당 네트워크 내에 ARP를 브로드캐스팅하여 해당 IP주소를 갖고 있는 노드는 자신의 MAC주소를 응답하는 형식으로 구현된다.


### 대상 서버와 TCP 소켓 연결 
목적지 서버의 주소를 알고난 후에 데이터 전송시 소켓을 열고, 연결형 통신 프로토콜인 TCP를 이용하여 데이터를 전송한다.  
TCP를 통해 데이터를 통신하기 위해서는 연결이 확인된 후 데이터를 보내야 하기 때문에, 연결 시작시 3-way-handshake를 이용하고, 해제시에는 4-way-handshake를 이용하여 접속을 끊는다.  
HTTPS요청이라면, TLS(Transpoart Layer Security) handshake 과정을 통해 세션키를 생성한다.

### HTTP프로토콜로 요청, 응답
세션이 유지되는 동안 서버에게 요청하고 응답받는 과정을 반복한다. 이 때 요청과 응답은 모두 HTTP 프로토콜을 사용하여 메시지를 생성한다.

### 브라우저에서 응답을 해석
웹 브라우저는 응답받은 HTML/CSS/JS 및 이미지, 폰트등의 리소스를 사용하여 페이지

** OSI 7계층과도 연관지어서 답할 수 있다
<details>
    <summary>꼬리질문</summary>

꼬리
</details>
</div>
</details>

<details>
    <summary>URL이란?</summary>
Uniform Resource Locator의 약자. 웹에서 정해진 자원의 주소를 말한다. 각각의 유일한 URL은 유일한 자원을 가리킨다.  
</details>

<details>
    <summary>IP주소와 MAC주소의 차이점</summary>
IP : 네트워크 통신에 있어 **통신기기**에 할당된 식별번호입니다.  
IP주소는 통신기기마다 고유하게 할당되어 있는 것이 아니라, 통신사에 일정 금액을 지불하고 받아오는 것이기 때문에 경우에 따라 바뀔 수 있습니다.
상대방 컴퓨터가 내 PC를 찾기 위해 필요한 주소입니다.  

MAC : IP주소와 마찬가지로 네트워크 통신에서 통신기기의 식별번호를 나타낸다.  
MAC주소는 **통신기기 하드웨어 자체에 부여된 고유한 식별번호**를 나타낸다.  
세상에 단 하나밖에 없는 유니크한 값을 가지며 변경될 수 없다. 컴퓨터간 서로 통신을 하기 위해 필요하다.

MAC주소와 IP주소는 왜 분리한 것일까?
IP주소는 네트워크 계층에서 사용하는 논리적인 주소이다. 목적지를 식별하는 값의 한가지인 것이다. IPX라는 프로토콜을 사용해도 동일하게 데이터 링크 계층의 프로토콜 이더넷과 통신이 가능하다. 즉, 네트워크 계층과 링크 계층의 식별자가 분리되어 있어 이렇게 독립적으로 프로토콜을 사용할 수 있는 것이다.


#### 물리 주소와 논리 주소 독립이 필요한 이유
마치 학번이 있는데 왜 주민번호가 필요하다고 묻는 것과 같은 이치이다.  
데이터를 A(제주도)에서 B(판교)로 보낸다고 가정을 해보자. 이 때 한번에 슝 하고 A에서 B로 가는 것이 아니라, 제주도 -> 경기도 -> 성남시 -> 분당구 이렇게 여러 스위치를 거쳐 도착지에 도달하게 된다. 이를 forwarding이라고 한다. 이렇듯, 한 명 한 명 찾아서  목적지에 도달하는 것보다 계층화된 구조로 타고타고 전달하는 것이 효율적이기 때문에 논리 주소를 사용하여 네트워크 계층화를 구현한 것이라고 볼 수 있다.

</details>


<details>
    <summary>네트워크의 통신 방식(브로드캐스트, 유니캐스트, 멀티캐스트)</summary>

* 유니캐스트 : 일대일 통신 방법.   
데이터를 보내고자 하는 주소(MAC Address)를 프레임에 포함시켜 보내는 방식
* 브로드캐스트 : 하나의 네트워크 전체의 통신 방법.  
같은 네트워크에 포함된 장비들에게 거부권은 없고 일단 무조건 수신하고 봐야하는 통신법
* 멀티캐스트 : 

</details>


<details>
    <summary>HTTP 프로토콜에 관해 설명해보시오</summary>
     Hyper Text Transfer Protocol의 약자로, 인터넷(www)에서 데이터를 주고받을 수 있는 프로토콜이다.  HTTP는 TCP/IP를 이용하는 응용 프로토콜이며, 연결상태를 유지하지 않는 비연결성 프로토콜이다. 그렇기 때문에 요청/응답 방식으로 동작한다.  
     HTTP에서 요청하는 메소드는 GET/POST/PUT/DELETE가 있다. 또한, HTTP는 단순 텍스트를 교환하기 때문에 보완에 취약하다.
     
   ** 서버가 요청에 대한 응답 코드는 아래로 나눌 수 있다 : 
*  1XX (조건부 응답) : 요청을 받았으며 작업을 계속한다.
*  2XX (성공) : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
*  3XX (리다이렉션 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
*  4XX (요청 오류) : 클라이언트에 오류가 있음을 나타낸다.
*  5XX (서버 오류) : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.
    
** 꼬리질문 : HTTP의 비연결성 프로토콜을 해결하기 위해 어떤걸 사용할까요?  
Cookie & Session
</details>

<details>
    <summary>HTTP와 HTTPS의 차이점</summary>
    HTTP는 Hyper Text Trnasfer Protocol의 약자로, WWW(웹)상에서 정보를 주고받는  가장 기초적인 프로토콜이다.즉, 클라이언트와 서버 간 웹문서를 통해 정보를 주고받는 규약을 뜻한다. HTTP는 네트워크, IPT, TCP, HTTP계층으로 구성되어있다. 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는 다는 것이 가장 큰 문제점이다.
    HTTPS는 Hyper Text Transfer Protocol Secure의 약자이다. HTTPS는 네트워크, IP, TCP, SSL/TLS, HTTPS계층으로 구성되어 있다. 데이터 도난 방지를 위해 SSL(보안 소켓 계층)을 이용하여 문제를 해결하였다. SSL은 서버와 브라우저 사이 암호화된 연결을 만들어 민감정보를 주고받을 시 도난당하는 것을 보완한다.
    보안적 측면을 제외하더라도, HTTPS로 전환시 검색엔진 최적화(SEO)에 있어서도 큰 혜택을 볼 수 있다. 또한 가속화된 모바일 페이지(AMP, Accelerated Mobile Pages)를 만들 때에도 HTTPS 프로토콜을 사용해야 한다.  
    HTTPS는 암호화된 통신을 제공하는 HTTP를 일컫는다. HTTP를 이용해 클라이언트각 서버와 통신을 할 때, 암호화 통신을 위한 키를 설정하고 통신하게 된다. 이 때 사용하는 암호화 방식은 공개키 암호화 방식을 사용하며, 데이터를 암호화하는데 2개의 키를, 복호화 하는데 한개의 키를 사용한다.  
    HTTP를 사용하면 공격자가 패킷을 가로챌 경우, 평문이기 때문에 해당 데이터를 갈취하고, 변조하여 공격이 가능하다(Man in the middle).  그에 반해 HTTPS 프로토콜을 사용하면, 패킷이 중간에 탈취되더라도 공격자가 메시지를 알아내고 암호화까지하여 변조하는데 천문학적인 시간을 소요하게 된다.  
    HTTPS 통신은 공개키 암호화, 복호화 과정으로 인해 많은 비용과 시간을 수반하기에, 금융정보 및 기밀 또는 민감한 정보들이 있을 경우 HTTPS로, 그와 상관없는 UI처리 및 일반 컨텐츠 정보는 HTTP로 처리한다.
    추가로 데이터를 송신할 때, HTTP는 애플리케이션 계층에서 전송계층(TCP)로 보내지만, HTTPS는 SSL로 전송하고, SSL은 전달받은 데이터를 암호화하여 TCP로 전달하는 방식으로 데이터를 송신한다. 반대로 데이터를 수신할 때, HTTP는 전송계층(TCP)에서 애플리케이션 계층인HTTP로 보내지만, HTTPS는 TCP에서 SSL로 전달하고, SSL은 복호화하여 애플리케이션계층(HTTPS)로 전달한다.
    
</details>

<details>
    <summary>HTTPS와 SSL</summary>
    HTTPS는 기존 HTTP에서 SSL(TLS)프로토콜을 가미하여 평문 데이터를 암호화하는 프로토콜이다.  HTTPS는 SSL 프로토콜
    SSL은 더 포괄적이며, 그 위에서 더 구체적으로 서비스 되는 것이 HTTPS이다. 즉, HTTPS는 SSL 위에서 돌아가는 프로토콜이다.(계층적으로 보면 HTTPS가 더 위에 있다)
       
</details>

<details>
    <summary>대칭키와 공개키에 대해 설명해주세요</summary>
    <div markdown="1">
  **대칭키**
  동일한 키로 암호화와 복호화를 같이 할 수 있는 암호화 기법을 말한다. 암호를 주고 받는 사람들 간 대칭키 전달이 어려우며, 대칭키 유출시 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물 될 수 있다.       
 **공개키**  
 두 개의 키를 가게 되는데, A키로 암호화 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식을 말한다. 이 방식에 착안하여 두 개의 키 중 하나를 비공개키로 하고, 나머지는 공개키로 지정한다.
  </div>
</details>

<details>
    <summary>SSL의 동작방식에 대해 설명해주세요.</summary>
    <div markdown="1">
    
  SSL은 공개키 암호화 방식과 공개키의 단점을 보완한 대칭키 암호화 방식을 함께 사용한다. 
  SSL 통신은 크게 handshake, 세션, 세션종료로 분류할 수 있다.
1~7까지가 hanshake이며, 8번이 세션, 8번이 세션폐기로 볼 수 있다. 
  1. 클라이언트에서 서버에 client hello 메시지를 보낸다.  
여기에는 클라이언트에서 가능한 TLS 버전, 서버 도메인, 세션 식별자, 암호 설정등 정보가 담겨져 있다.
  2. 클라이언트의 메시지를 받은 서버는 Server hello 메시지를 클라이언트에게 보낸다.
  3. 서버가 클라이언트에게 Certificate 메시지를 보낸다. 여기에는 서버의 인증서가 들어간다. 전송이 끝나면 ServerHelloDone 메시지를 보내 끝났음을 알린다.
  4. 클라이언트는 서버가 보낸 인증서를 검증한다.
  5. 클라이언트는 임의의 pre-master secret을 생성한 뒤, 서버가 보낸 인증서에 포함된 공개키를 사용해 암호화한다.
  이렇게 암호화된 pre-master secret을 서버에 전달한다.
  6. 서버는 전송받은 정보를 복화하하여 pre-master secret을 알아낸 뒤, 이 정보를 사용해 master secret을 생성한다.  
  그 뒤 master secret에서 세션 키를 생성해내며, 이 세션 키는 앞으로 서버와 클라이언트 간 통신을 암호화하는데 사용할 것이다. 클라이언트 역시 본인이 만들어낸 pre-master secret을 알고 있으므로, 같은 과정을 거쳐 세션 키를 스스로 만들 수 있다.
  7. 이제 서버와 클라이언트는 각자 동일한 세션 키를 가지고 있으며, 이를 사용해 대칭 키 암호를 사용하는 통신을 할 수 있다. 통신시 양구간은 세션키를 사용해 암호화해 보낼 것을 알려준 뒤, finished 메시지를 보내 각자 핸드셰이킹 과정이 끝났음을 알려준다.
  8. 서버와 클라이언트간 보안 통신이 구성된다.
  9. 통신이 끝나면 세션키는 폐기된다.
</div>
</details>


<details>
    <summary>GET과 POST방식의 차이점</summary>
    **GET**  
    필요한 데이터를 쿼리스트링(URL의 끝에 ?와 함께 이름과 값을 쌍으로 이루는 것)을 통해 전송한다. 그리고 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생 할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용한다.  
    **POST**   
    리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 HTTP 메시지의 Body에 담아 전송한다. 그렇기에 길이의 제한없이 데이터를 전송할 수 있으며, 대용량 데이터 전송 또한 가능하다. 이렇듯 데이터가 Body로 전송되고 눈에 보이지 않아 GET보다 보안적인 면에서 안전하다고 생각할 수 있지만, 개발자 도구등에서 확인할 수 있기에 민감 데이터의 경우 반드시 암호화하여 전송해야 합니다.  
    그리고 POST로 요청을 보낼 때에는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 한다. 그러지 않을 경우 내용 혹은 URL에 포함된 리소스의 확장자명으로 유추한다.  
    GET방식은 Idempotent(멱등), POST는 Non-idempotent하게 설계되었다.
    GET으로 서버에게 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 하도록 설계되었기 때문에, 주로 조회할 때 사용한다. 반면, POST는 Non-idempotent이기에 서버에게 동일한 요청을 하더라도 응답은 항상 다를 수 있다. 이에 따라 POST는 서버의 상태나 데이터를 변경시킬 때 사용된다.
    
</details>

### TCP에 대해 설명해주세요.  
**TCP(Transport Connection Protocol)**란 End Point간 신뢰성 있는 데이터를 전달하기 위한 연결성 프로토콜이다. TCP는 3 way hand-shaking을 통해 세션 연결 후, 데이터를 주고받을 수 있다.

TCP 서버의 특징은   
1)서버소켓은 연결만 담당한다.  
2) 서버와 클라이언트는 1대 1로 연결된다.  
3) 스트림 전송으로 전송 데이터 크기가 무제한이다.  
4) 패킷에 대한 응답이 필요하므로 성능이 낮다.  
5) 스트리밍 서비스에 불리하다.(손실된 경우 재전송 요청을 함)

#### TCP 연결과 해제
TCP는 연결시에 **3 way hand-shake**를 사용하고, 해제시에눈 **4-way hand-shake**를 사용한다.  
연결 과정은 아래와 같다.
1. 클라이언트가 서버에게 연결 요청 메시지를 전송(SYN).  
2. 서버는 클라이언트의 메시지를 받아 연결을 수락한다는 SYN + ACK를 전송.  
3. 클라이언트가 다시 ACK를 보내고 연결을 맺는다.

이러한 과정과 혼잡제어, 흐름제어를 통해 신뢰성을 보장한다.  

해제 과정은 아래와 같다.  
1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.  
2. 서버는 ACK를 보내고, 자신의 통신이 끝날 때까지 기다린다.(TIME_WAIT)
3. 서버가 통신이 끝나면, 연결이 종료되었다는 FIN 플래그를 전송한다.
4. 클라이언트는 확인했다는 ACK를 보내고 종료한다.

### UDP에 대해 설명해주세요.
데이터 중심 프로토콜로, 주고받는 통신보다 데이터를 일방적으로 보내는 것을 중요시 하는 프로토콜이다.   전송속도가 TCP에 비해 빠른 프로토콜이다. Connectionless Oriented Service로 별도의 연결 설정이나 해제 과정이 존재하지 않다.

UDP서버의 특징은  
1) 비연결형 서비스로 데이터그램 방식을 제공한다.  
2) 연결을 설정하고 해제하는 과정이 존재하지 않는다.    
3) 정보를 주고 받을 때 정보를 보내거나, 받는다는 절차를 거치지 않는다.  
4) UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.  
5) 신뢰성이 낮다.  
6) TCP보다 속도가 빠르다.  
7) 패킷에 순서를 부여하여 재조립을 하거나 흐름 제어 또는 혼잡 제어와 같은 기능을 처리하지 않는다.  
### 소켓이란
***
*** 
참고 자료 : 
1. [브라우저 URL 입력 후 일어나는 일](https://wangin9.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL-%EC%9E%85%EB%A0%A5-%ED%9B%84-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EB%93%A4-1URL%EC%9D%84-%ED%95%B4%EC%84%9D%ED%95%9C%EB%8B%A4?category=827054)
2. [당신이 브라우저로 웹사이트에 접속할 때 일어나는 일들 (부제: DNS 이야기)](https://preamtree.tistory.com/35)
1. [InterviewFAQ-network](https://github.com/MoctorDaster/InterviewFAQ-network#%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E6%80%BB%E8%BF%B0). 
 2. [Backend-Interview-Question](https://github.com/ksundong/backend-interview-question)
 3. [GET과 POST의 차이](https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/)
