---
layout: post
title: Back-end Developer Interview
categories: [Interview]
tags: [Interview]
description: 
fullview: false
comments: false
---
백엔드 면접 준비를 위한 CS 지식 복습.   
질문에 대한 답변은 __간단__하게, 하지만 해당 지식은 __깊이__있게 공부하도록 하는 것이 목표이다.

# 네트워크
***
를 렌더링한다. 서버와의 세션이 종료되면 4-way handshake로 연결을 종료한다.

<details>
    <summary>사용자가 URL에 https://www.google.com을 입력하고, 엔터를 쳤을 때 발생하는 일련의 작업 설명</summary>

<!-- summary 아래 한칸 공백 두고 내용 삽입 -->

웹통신의 기준으로 흘러가는 관점을 파악
### 브라우저의 URL파싱  
아래의 URL을 입력했다고 가정해보자.
><span style="color:red"> http</span>://<span style="color:orange">www.example.com </span><span style="color:blue">:80 </span><span style="color:green">/path/to/myfile.html </span><span style="color:purple">?key1=value1&key2=value2</span><span style="color:grey"> #SomewhereInTheDocument</span>  
1) <span style="color:red"> http</span>:  
'하이퍼 텍스트 통신 규약'을 사용하라는 뜻.
2)<span style="color:orange">www.example.com </span>  
어떤 웹서버가 요구되는지 명시. 직접 IP주소를 입력하는 것도 가능하지만, 인간의 나태함에 의해 개발된 위대한 도메인 URL을 사용한다.  
3) <span style="color:blue">:80 </span>. 
포트. 기술적으로 웹서버에서 자원을 접근하기 위해 사용되는 gate이다. 표준 HTTP포트 사용시(http:80, https:443) 포트 번호는 생략한다.  
4)<span style="color:green">/path/to/myfile.html </span>  
웹서버 자원에 대한 경로. 초기에는 물리적 파일 위치를 가르켰으나, 요즘은 웹서버에서 추상화한 경로를 표기한다.  
5) <span style="color:purple">?key1=value1&key2=value2</span>  
웹 서버에서 제공되는 추가 파라미터. get방식 사용시 보통 제공된다.  
6) <span style="color:grey"> #SomewhereInTheDocument</span>   
자원 자체에 다른 부분에 대한 anchor(닻), 일종의 북마크이다.   
북마크된 지점에 위치한 내용을 보여주기 위헤 브라우저에서 방향을 알려주며, 요청이 서버에 보내지지는 않는다.

#### 유니코드 문자열 반환  
브라우저는 호스트명에서 ASCII가 아닌 유니코드 문자열을 반환한다.  
한글을 비롯한 유니코드가 있을 때 브라우저가 URL에서 호스트명 부분에 퓨니코드 인코딩을 한다.  
** 퓨니코드 : 도메인 이름에 쓸 수 있는 문자만으로 다른 유니코드 문자를 표기하기 위해 만들어진 인코딩 방식. 가끔 한글을 url에서 표시할 때 %ED%93% 이런 것을 본적있을 것임.

### HSTS 목록 조회
브라우저는 HSTS리스트를 점검한다. 만일 해당 URL이 있을 경우, http로 요청하더라도 자동으로 https로 변환하여 요청하게 된다.  
** 여기서 HSTS(HTTP Strict Transport Security)란 ? HTTP를 허용하지 않고 HTTPS를 통해서만 연결이 가능하도록 하는 기능이다. HTTP를 통한 연결 자체를 허용하지 않으며, 클라이언트측에서 차단되는 장점이 있다.

### DNS 서버를 통해 도메인 주소를 IP주소로 변환. 
우선 로컬 host파일이나 브라우저 캐시에 도메인이 있는지 확인한다.  
사용자의 PC는 가장 먼저, 지정된 DNS서버(우리나라의 경우 통신사 별로 지정된 DNS서버가 있다.)에 DNS Query를 송신한다.(http://www.naver.com으로 가정하자) 그 후 지정된 DNS서버는 Root 네임서버에 www.naver.com을 질의하고, Root 네임서버는 .com 네임서버의 ip주소를 알려준다.   

 그 후 .com 네임서버에 www.naver.com을 질의하면 naver.com 네임서버의 ip주소를 받고, 그곳에 질의를 또 송신하면 www.naver.com의 IP주소를 수신하게 된다.

 이와 같이 여러번 왔다갔다 하는 이유는, 도메인의 계층화 구조에 따라 DNS서버도 계층화되어있기 때문이다. 이렇게 계층화되어 있으므로 도메인의 가장 최상단, 즉 가장 뒷쪽(.com, .kr 등등)을 담당하는 DNS서버는 전세계에 13개 뿐이다.


### 라우터를 통해 해당 서버의 게이트웨이까지 이동
  DNS 서버를 통해 접속하고자 하는 서버의 IP주소를 알아냈다. 이제 이 IP주소로 서버에 요청을 전달해야 한다.  
  이 IP주소로 가야하는 것은 알지만, 어떻게 가야할 지는 모르기 때문에 네트워크 장비인 라우터의 라우팅 테이블을 통해 어떤 경로로 요청할지 지정한다. 이를 통해 서버로 찾아갈 수 있게 된다.

### ARP를 통해 IP주소를 MAC주소로 변환  
ARP(Address Resolution Protocol, 주소 결정 프로토콜)은 OSI 7계층 중에서도, 네트워크 계층 주소와 링크 계층 주소 사이의 변환을 담당하는 'IP 프로토콜'이다.

실질적으로 컴퓨터는 '랜카드'를 사용하여 연결되어 있어, 3계층->2계층으로 데이터를 전달하기 위해서는 MAC주소가 필요하다.
이를 위해 해당 네트워크 내에 ARP를 브로드캐스팅하여 해당 IP주소를 갖고 있는 노드는 자신의 MAC주소를 응답하는 형식으로 구현된다.


### 대상 서버와 TCP 소켓 연결 
목적지 서버의 주소를 알고난 후에 데이터 전송시 소켓을 열고, 연결형 통신 프로토콜인 TCP를 이용하여 데이터를 전송한다.  
TCP를 통해 데이터를 통신하기 위해서는 연결이 확인된 후 데이터를 보내야 하기 때문에, 연결 시작시 3-way-handshake를 이용하고, 해제시에는 4-way-handshake를 이용하여 접속을 끊는다.  
HTTPS요청이라면, TLS(Transpoart Layer Security) handshake 과정을 통해 세션키를 생성한다.

### HTTP프로토콜로 요청, 응답
세션이 유지되는 동안 서버에게 요청하고 응답받는 과정을 반복한다. 이 때 요청과 응답은 모두 HTTP 프로토콜을 사용하여 메시지를 생성한다.

### 브라우저에서 응답을 해석
웹 브라우저는 응답받은 HTML/CSS/JS 및 이미지, 폰트등의 리소스를 사용하여 페이지

** OSI 7계층과도 연관지어서 답할 수 있다
<details>
    <summary>꼬리질문</summary>

꼬리
</details>
</details>

<details>
    <summary>URL이란?</summary>
Uniform Resource Locator의 약자. 웹에서 정해진 자원의 주소를 말한다. 각각의 유일한 URL은 유일한 자원을 가리킨다.  
</details>

<details>
    <summary>IP주소와 MAC주소의 차이점</summary>
IP : 네트워크 통신에 있어 **통신기기**에 할당된 식별번호입니다.  
IP주소는 통신기기마다 고유하게 할당되어 있는 것이 아니라, 통신사에 일정 금액을 지불하고 받아오는 것이기 때문에 경우에 따라 바뀔 수 있습니다.
상대방 컴퓨터가 내 PC를 찾기 위해 필요한 주소입니다.  

MAC : IP주소와 마찬가지로 네트워크 통신에서 통신기기의 식별번호를 나타낸다.  
MAC주소는 **통신기기 하드웨어 자체에 부여된 고유한 식별번호**를 나타낸다.  
세상에 단 하나밖에 없는 유니크한 값을 가지며 변경될 수 없다. 컴퓨터간 서로 통신을 하기 위해 필요하다.

MAC주소와 IP주소는 왜 분리한 것일까?
IP주소는 네트워크 계층에서 사용하는 논리적인 주소이다. 목적지를 식별하는 값의 한가지인 것이다. IPX라는 프로토콜을 사용해도 동일하게 데이터 링크 계층의 프로토콜 이더넷과 통신이 가능하다. 즉, 네트워크 계층과 링크 계층의 식별자가 분리되어 있어 이렇게 독립적으로 프로토콜을 사용할 수 있는 것이다.


#### 물리 주소와 논리 주소 독립이 필요한 이유
마치 학번이 있는데 왜 주민번호가 필요하다고 묻는 것과 같은 이치이다.  
데이터를 A(제주도)에서 B(판교)로 보낸다고 가정을 해보자. 이 때 한번에 슝 하고 A에서 B로 가는 것이 아니라, 제주도 -> 경기도 -> 성남시 -> 분당구 이렇게 여러 스위치를 거쳐 도착지에 도달하게 된다. 이를 forwarding이라고 한다. 이렇듯, 한 명 한 명 찾아서  목적지에 도달하는 것보다 계층화된 구조로 타고타고 전달하는 것이 효율적이기 때문에 논리 주소를 사용하여 네트워크 계층화를 구현한 것이라고 볼 수 있다.

</details>


<details>
    <summary>네트워크의 통신 방식</summary>

* 유니캐스트 : 일대일 통신 방법.   
데이터를 보내고자 하는 주소(MAC Address)를 프레임에 포함시켜 보내는 방식
* 브로드캐스트 : 하나의 네트워크 전체의 통신 방법.  
같은 네트워크에 포함된 장비들에게 거부권은 없고 일단 무조건 수신하고 봐야하는 통신법
* 멀티캐스트 : 

</details>


<details>
    <summary>HTTP 프로토콜에 관해 설명해보시오</summary>
     Hyper Text Transfer Protocol의 약자로, 인터넷(www)에서 데이터를 주고받을 수 있는 프로토콜이다.  HTTP는 TCP/IP를 이용하는 응용 프로토콜이며, 연결상태를 유지하지 않는 비연결성 프로토콜이다. 그렇기 때문에 요청/응답 방식으로 동작한다.  
     HTTP에서 요청하는 메소드는 GET/POST/PUT/DELETE가 있다. 또한, HTTP는 단순 텍스트를 교환하기 때문에 보완에 취약하다.
     
   ** 서버가 요청에 대한 응답 코드는 아래로 나눌 수 있다 : 
*  1XX (조건부 응답) : 요청을 받았으며 작업을 계속한다.
*  2XX (성공) : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
*  3XX (리다이렉션 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
*  4XX (요청 오류) : 클라이언트에 오류가 있음을 나타낸다.
*  5XX (서버 오류) : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.
    
** 꼬리질문 : HTTP의 비연결성 프로토콜을 해결하기 위해 어떤걸 사용할까요?  
Cookie & Session
</details>

<details>
    <summary>HTTP와 HTTPS의 차이점</summary>
    HTTP는 Hyper Text Trnasfer Protocol의 약자로, WWW(웹)상에서 정보를 주고받는  가장 기초적인 프로토콜이다.즉, 클라이언트와 서버 간 웹문서를 통해 정보를 주고받는 규약을 뜻한다. HTTP는 네트워크, IPT, TCP, HTTP계층으로 구성되어있다. 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는 다는 것이 가장 큰 문제점이다.
    HTTPS는 Hyper Text Transfer Protocol Secure의 약자이다. HTTPS는 네트워크, IP, TCP, SSL/TLS, HTTPS계층으로 구성되어 있다. 데이터 도난 방지를 위해 SSL(보안 소켓 계층)을 이용하여 문제를 해결하였다. SSL은 서버와 브라우저 사이 암호화된 연결을 만들어 민감정보를 주고받을 시 도난당하는 것을 보완한다.
    보안적 측면을 제외하더라도, HTTPS로 전환시 검색엔진 최적화(SEO)에 있어서도 큰 혜택을 볼 수 있다. 또한 가속화된 모바일 페이지(AMP, Accelerated Mobile Pages)를 만들 때에도 HTTPS 프로토콜을 사용해야 한다.  
    HTTPS는 암호화된 통신을 제공하는 HTTP를 일컫는다. HTTP를 이용해 클라이언트각 서버와 통신을 할 때, 암호화 통신을 위한 키를 설정하고 통신하게 된다. 이 때 사용하는 암호화 방식은 공개키 암호화 방식을 사용하며, 데이터를 암호화하는데 2개의 키를, 복호화 하는데 한개의 키를 사용한다.  
    HTTP를 사용하면 공격자가 패킷을 가로챌 경우, 평문이기 때문에 해당 데이터를 갈취하고, 변조하여 공격이 가능하다(Man in the middle).  그에 반해 HTTPS 프로토콜을 사용하면, 패킷이 중간에 탈취되더라도 공격자가 메시지를 알아내고 암호화까지하여 변조하는데 천문학적인 시간을 소요하게 된다.  
    HTTPS 통신은 공개키 암호화, 복호화 과정으로 인해 많은 비용과 시간을 수반하기에, 금융정보 및 기밀 또는 민감한 정보들이 있을 경우 HTTPS로, 그와 상관없는 UI처리 및 일반 컨텐츠 정보는 HTTP로 처리한다.  
    
</details>

<details>
    <summary>HTTPS와 SSL</summary>
    HTTPS는 기존 HTTP에서 SSL(TLS)프로토콜을 가미하여 평문 데이터를 암호화하는 프로토콜이다.  HTTPS는 SSL 프로토콜
       
</details>


<details>
    <summary>SSL의 동작방식에 대해 설명해주세요.</summary>
    SSL은 공개키 암호화 방식과 공개키의 단점을 보완한 대칭키 암호화 방식을 함께 사용한다.  
    공개키 방식으로 대칭키를 전달하고, 서로 공유된 대칭키를 가지고 통신한다.  
    
</details>


<details>
    <summary>GET과 POST방식의 차이점</summary>
    **GET**  
    필요한 데이터를 쿼리스트링(URL의 끝에 ?와 함께 이름과 값을 쌍으로 이루는 것)을 통해 전송한다. 그리고 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생 할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용한다.  
    **POST**   
    리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 HTTP 메시지의 Body에 담아 전송한다. 그렇기에 길이의 제한없이 데이터를 전송할 수 있으며, 대용량 데이터 전송 또한 가능하다. 이렇듯 데이터가 Body로 전송되고 눈에 보이지 않아 GET보다 보안적인 면에서 안전하다고 생각할 수 있지만, 개발자 도구등에서 확인할 수 있기에 민감 데이터의 경우 반드시 암호화하여 전송해야 합니다.  
    그리고 POST로 요청을 보낼 때에는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 한다. 그러지 않을 경우 내용 혹은 URL에 포함된 리소스의 확장자명으로 유추한다.  
    GET방식은 Idempotent(멱등), POST는 Non-idempotent하게 설계되었다.
    GET으로 서버에게 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 하도록 설계되었기 때문에, 주로 조회할 때 사용한다. 반면, POST는 Non-idempotent이기에 서버에게 동일한 요청을 하더라도 응답은 항상 다를 수 있다. 이에 따라 POST는 서버의 상태나 데이터를 변경시킬 때 사용된다.
    
</details>

### 소켓이란
***
*** 
참고 자료 : 
1. [브라우저 URL 입력 후 일어나는 일](https://wangin9.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL-%EC%9E%85%EB%A0%A5-%ED%9B%84-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EB%93%A4-1URL%EC%9D%84-%ED%95%B4%EC%84%9D%ED%95%9C%EB%8B%A4?category=827054)
2. [당신이 브라우저로 웹사이트에 접속할 때 일어나는 일들 (부제: DNS 이야기)](https://preamtree.tistory.com/35)
1. [InterviewFAQ-network](https://github.com/MoctorDaster/InterviewFAQ-network#%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E6%80%BB%E8%BF%B0). 
 2. [Backend-Interview-Question](https://github.com/ksundong/backend-interview-question)
 3. [GET과 POST의 차이](https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/)
