---
layout: post
title: [스프링 핵심 원리 기본편] 1. 객체 지향 설계와 스프링
categories:[Java, Spring Framework]
tags: [Java, Spring Framework, 스프링 핵심 원리 기본편]
description: 인프런에서 김영한 강사님이 강의해주시는 내용을 토대로 정리  
fullview: false
comments: true
---
다른 분의 강의를 듣다가, 개인적으로는 document reference를 보며 예제를 따라하고 (가끔) 강의가 중구난방으로 흘러가다보니 이해하기 어려운 부분이 있었다.  
스프링에 대해 깊게 알지 못하다 보니 그 수준을 따라가기 힘들어 충동적으로 김영한님의 강의를 구매하여 듣기 시작했다.  
개인적으로 지금 막 듣기 시작했지만, 훨씬 강의를 성의있게 준비해주시고 꼼꼼하게 설명해주시는 것 같아 훠얼씬 만족하며 시간가는줄 모르고 수강하고 있다 XD
***
# 자바 진영의 역사와 스프링
## 옛날 옛적에..
2000년대 초, EJB(Enterprise Java Beans)가 주를 이루었다고 한다. 자바 진영에서 표준으로 잡힌 기술
하지만 의존적으로 코딩을 하기엔 점점 복잡해지고, 개발자가 점점 더 힘들어 했다고 한다.  
기술 수준 자체도 낮고(Hello World) 같았다고 한다..

## EJB라는 지옥에서 탈출해준 두가지 기술
#### Spring  
EJBB보다 훨씬 단순하며 간단하게 코딩할 수 있는 프레임워크  
EJBB의 문제점을 하나하나 짚으며, 대체할 수 있는 프레임워크를 책으로 기술하였다.  
그 결과, 사람들이(개발자) 오..그래..!하고 동의하며 예제코드를 직접 본인의 프로젝트에 사용하며 점점 유명해진다.  

#### Hibernate  
EJB 엔티티빈 기술을 대체하며 ,JPA(Java Persistance API)의 새로운 표준을 정의

이 결과,
EJB 엔티티빈이 추락하고 하이버네이트가 등장하였으며, 하이버네이트를 기준으로 한 JPA가 등장하게 되었다.  

ORM진영은 JPA가 안착하였으며, JPA구현체 중 하이버네이트가 80%가량의 점유율을 차지하고 있다.



#### ORM
Java에서 쿼리로 사용하지 않고 객체화 하는 방식!


#### 간단하게 스프링 버전에 따른 변화 
스프링 프레임워크 4.X X : 자바 8버전대 지원
스프링 프레임워크 5.X X : 비동기 넌블럭킹 지원(Node.js)를 지원  


*** 
# 스프링 프레임워크
*  핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
*  웹 기술 : 스프링 MVC, 스프링 WebFlux
*  데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
*  기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
*  테스트 : 스프링 기반 테스트 지원
*  언어 : 코틀린, 그루비  

**스프링** 단어를 지칭하는 의미 ?  
* 스프링 DI 컨테이너  
* 스프링 프레임워크  
* 스프링 부트, 프레임워크등 스프링으로 이루어지고 있는 생태계 

# 스프링부트
스프링을 편하게 사용할 수 있도록 지원, 최근에는 기본으로 사용(스프링부트는 스프링 프레임워크없이 사용할 수 없다)
* 톰캣같은 웹 서버를 내장해서 별도의 웹서버 설치 불필요  
* 손쉬운 빌드 구성을 위한 starter 종속성 제공  
* 스프링과 3rd party 라이브러리 자동 구성(라이브러리 버전관리..)  
* 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공  
* 관례에 의한 간결한 설정  


## 스프링은 왜 만든것인가?
스프링은 자바 언어 기반의 프레임워크이다. 자바의 가장 큰 특징은 **객체 지향 언어**이기 때문에, 스프링 프레임워크는 객체 지향 언어가 가진 가장 강력한 특징을 살려낼 수 있는 프레임워크라고 할 수 있다.  
또한, 스프링은 **좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임워크이다. 

***
# 좋은 객체 지향 프로그래밍이란?  

## 객체 지향 프로그래밍
* 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **"객체"**들의 **모임**으로 파악하고자 하는 것이다. 각각의 **객체**는 **메시지**를 주고받고, 데이터를 처리 할 수 있다. (협력)
* 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때뭉네 대규모 소프트웨어 개발에 많이 사용된다.  
**유연**하고 **변경**이 용이하다는 것은, 키보드와 마우스를 바꾸는 것과 같이 **다형성**을 적용하는 것을 의미한다.
  
### 다형성    
**다형성** (Polymorphism) : **역할**과 **구현**으로 세상을 구분  
#### 다형성을 실세계로 비유한다면?  
* 운전자 - 자동차
* 공연 무대  
* 키보드, 마우스 등 표준 인터페이스
* 할인 정책 로직

이렇게 **역할**과 **구현**으로 세상을 구분하면, 훨씬 **유연**하며 **변경**도 편리해진다.  
#### 장점  
* 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
* 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
* 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.  
* 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.  
=====> 그렇기 때문에 **역할**(인터페이스)를 안정적으로 잘 설계하는 것이 굉.장.히 중요하다.

자바에서는  
* 역할  = 인터페이스  
* 구현 = 인터페이스를 구현한 클래스, 구현 객체  
와 같은 방식으로 다형성을 활용한다. 이렇게 객체를 설계할 때 **역할**과 **구현**을 명확히 분리한다.(물론 역할을 먼저 설계하고, 그 후 구현한다.)

#### 자바 언어에서의 다형성
* 오버로딩 => 여러 개의 메소드를 다른 파라미터 방식으로 여러개 정의 할 수 있는 것
* 오버라이드 => 부모 혹은 인터페이스로부터 정의되어있는 메소드를 상속 or 구현하여 재정의 할 수 있는 것.

### 객체의 협력이라는 관계로 다시 생각해보자.  
혼자있는 객체는 없다.  
웹 서버에서 예를 들어보면, 클라이언트는 요청하며 서버는 응답한다. 수많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.  

### 다형성의 본질  
* 인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 **유연**하게 변경 할 수 있다.  
* 이러한 다형성은 객체간 **협력**이라는 본질에서부터 시작된다.
* 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 할 수 있다.

## 스프링과 객체 지향
* 다형성이 가장 중요하다.  
* 스프링은 다형성을 극대화하여 이용할 수 있도록 도와준다.  
* 스프링에서 제공하는 IoC, DI는 다형성을 이용하여 **역할**과 **구현**을 편리하게 다룰 수 있도록 지원한다.  
(=> 공연 무대의 배우를 바꾸듯이, 차를 소나타에서 테슬라로 바꾸듯이 편리하게 바꾸는 것을 말한다!)

***
# 좋은 객체 지향 설계의 5가지 원칙(SOLID)  
클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리  
* SRP : 단일 책임 원칙(single responsibility principle)  
* OCP : 개방-폐쇄 원칙(Open-closed principle)  
* LSP : 리스코프 치환 원칙(Liskov substitution principle)  
* ISP : 인터페이스 분리 원칙(Interface segregation principle)  
* DIP : 의존관계 역전 원칙(Dependency inversion principle)  

## SRP : 단일 책임 원칙(single responsibility principle)  
* 하나의 클래스는 하나의 책임만 가져야 한다.  
* 하나의 책임이라는 것은 모호해서, 역할에 따라 크고 작을 수 있다.
책임의 기준은? **변경**이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것  
예)UI변경, 객체 생성과 사용을 분리

## OCP : 개방-폐쇄 원칙(Open-closed principle)  
* 소프트웨어 요소는 **확장**에는 열려있으나 **변경**에는 닫혀 있어야 한다.  
* **다형성**을 생각하며 이해해보자(**역할**과 **구현**의 분리)  
즉, 인터페이스를 이용해서 새로운 구현 클래스를 만드는 것(확장)은 열려있으나, 인터페이스 자체를 변경하는 것은 인터페이스를 구현한 클래스 모두 변경해야 하기 때문에 OCP를 지켰다고 볼 수 있다.

### OCP의 문제점?
* 클라이언트가 구현 클래스를 직접 선택하여 변경한다.
* 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 이렇게 되면 OCP를 지킬 수 없다.  
* 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.  (스프링 컨테이너가 해준다!)

## LSP : 리스코프 치환 원칙(Liskov substitution principle) 

* 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 세상에 정의된 기능을 보장해주어야 한다는 것을 말한다.
* 컴파일 단계를 말하는 것이 아니다.  
예시 : 자동차 인터페이스의 엑셀은 앞으로 가야하는 기능, 뒤로 가게 하면 LSP 위반, 느리더라도 앞으로 가야한다.  

## ISP : 인터페이스 분리 원칙(Interface segregation principle)  
* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.  
예시 : 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
          사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리  
*  분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
*  인터페이스가 명확해지고, 대체 가능성이 높아진다.

## DIP : 의존관계 역전 원칙(Dependency inversion principle)  
* 구현 클래스에 의존하지 않고, 인터페이스에 의존해야 한다.  
* 앞서 이야기한 **역할**에 의존해야 한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경 할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다.

## 정리
* 객체 향의 핵심은 다형성이다.  
* 하지만 다형성만으로는 부품을 갈아끼우듯이 개발할 수 없다.  
* 다형성만으로는 클라이언트 코드와 함께 변경된다.  
* 다형성만으로는 **OCP,DIP**를 지킬 수 없다.  
* 뭔가 더 필요하다 ! (=>다음 챕터에서 스프링 컨테이너에 대해 이야기 할 것 같다)

***
# 객체 지향 설계와 스프링
## 스프링이란?
* 다형성 + OCP,DIP를 가능하게 지원해주는 프레임워크이다.(어떻게 ? => **DI Container**를 이용하여 해결했다!)
* 클라이언트 코드의 변경 없이 기능을 확장할 수 있다. 그래서 쉽게 부품 교체하듯 개발할 수 있다.


***
### 강사님이 추천해주신 책
* 객체지향의 사실과 오해  
* 토비의 스프링  
* 자바 ORM 표준 JPA 프로그래밍  

***

앞선 내용은 김영한 강사님의 [스프링 핵심 원리 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8) 강의를 들으며 정리한 내용입니다.  

